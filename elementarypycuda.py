# -*- coding: utf-8 -*-
"""elementaryPyCUDA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15woCGygHBFvIWObWIMJChXVi1Dl_q8Y7

Further information at: https://documen.tician.de/pycuda/array.html
"""

!pip install pycuda

import numpy as np

import pycuda.autoinit
import pycuda.gpuarray as gpuarray
import pycuda.cumath

h_x = np.zeros((32, 32), dtype = np.float32)
h_x[0, 0] = 11
h_x[2, 31] = -4

d_x = pycuda.gpuarray.to_gpu(h_x)

h_y = d_x.get()
print(h_y)

d_x = gpuarray.zeros((32, 32), np.float32)
print(d_x)

d_y = gpuarray.empty((32, 32), np.float32)
print(d_y)

d_z = gpuarray.empty_like(d_x)
print(d_z)

d_w = gpuarray.zeros_like(d_x)
print(d_w)

d_h = gpuarray.ones_like(d_x)
print(d_h)

d_g = pycuda.gpuarray.arange(0, 10, 0.1, dtype = np.float32)
print(d_g)

d_w = d_w.fill(3)
print(d_w)

"""We do not have ```gpuarray.ones```, but we do have ```gpuarray.zeros``` and ```gpuarray.ones_like```. We try first ```gpuarray.zeros``` with single precision elements and add elementwise $1$.


"""

d_x = 1 + gpuarray.zeros((32, 32), np.float32)
print(d_x)

"""Now we make elementwise operations:"""

d_y = np.float32(3) * gpuarray.ones_like(d_x, np.float32)

d_z = d_y * pycuda.cumath.exp(1j * np.pi * d_x)

print(d_z)

"""Complex numbers manipulations. Taking real and imaginary parts. """

d_y_real = d_y.real
d_y_imag = d_y.imag

print(d_y_real)
print(d_y_imag)

d_y = 1j * d_y
print(d_y)

d_y.conj(d_y)
# d_y = d_y.conj()
print(d_y)

"""Computing the power of real and complex arrays."""

d_w     = d_y_real.__pow__(3)
print(d_w.real)

d_z     = pycuda.cumath.exp(1j * (np.pi / 2) * d_x)
d_w     = d_z.__pow__(2)
print(d_w)

"""Computing the ```abs``` of a complex array.


"""

d_z     = (1 + 1j) * d_x
d_w     = d_z.__abs__()
print(d_w)

"""Trigonometric and hyperbolic trigonometric functions of complex arrays, fundamental mathematical functions of complex arrays."""

d_z     = pycuda.cumath.sin((1 + 1j) * d_x)
print(d_z)

d_z     = pycuda.cumath.cos((1 + 1j) * d_x)
print(d_z)

d_z     = pycuda.cumath.tan((1 + 1j) * d_x)
print(d_z)

d_z     = pycuda.cumath.sinh((1 + 1j) * d_x)
print(d_z)

d_z     = pycuda.cumath.cosh((1 + 1j) * d_x)
print(d_z)

d_z     = pycuda.cumath.tanh((1 + 1j) * d_x)
print(d_z)

d_z     = pycuda.cumath.exp((1 + 1j) * d_x)
print(d_z)

d_z     = pycuda.cumath.log((1 + 1j) * d_x)
print(d_z)

d_z     = pycuda.cumath.sqrt((1 + 1j) * d_x)
print(d_z)

"""Other mathematical operations defined on real arrays."""

d_z     = pycuda.cumath.asin(d_x)
print(d_z)

d_z     = pycuda.cumath.acos(d_x)
print(d_z)

d_z     = pycuda.cumath.atan(d_x)
print(d_z)

d_z     = pycuda.cumath.log10(d_x)
print(d_z)

d_z     = pycuda.cumath.fabs(-d_x)
print(d_z)

d_z     = pycuda.cumath.ceil(1.6 * d_x)
print(d_z)

d_z     = pycuda.cumath.floor(1.1 * d_x)
print(d_z)

"""Conditional operations"""

h_x = np.zeros((5, 1), dtype = np.float32)
h_x[0] = 11
h_x[1] = -4
h_x[2] = 77
h_x[3] = -14
h_x[4] = 0

h_y = np.zeros((5, 1), dtype = np.float32)
h_y[0] = 12.3
h_y[1] = 11.4
h_y[2] = -7
h_y[3] = 0
h_y[4] = 12

d_x = pycuda.gpuarray.to_gpu(h_x)
d_y = pycuda.gpuarray.to_gpu(h_y)

d_h = pycuda.gpuarray.if_positive(d_x - d_y, d_x, d_y)
print(d_h)

d_h = pycuda.gpuarray.maximum(d_x, d_y)
print(d_h)

d_h = pycuda.gpuarray.minimum(d_x, d_y)
print(d_h)

"""Reductions."""

d_red = pycuda.gpuarray.sum(d_x)
print(d_red)

d_red = pycuda.gpuarray.max(d_x)
print(d_red)

d_red = pycuda.gpuarray.min(d_x)
print(d_red)

d_red = pycuda.gpuarray.dot(d_x, d_y)
print(d_red)

h_index = np.zeros((3, 1), dtype = np.int32)
h_index[0] = 0
h_index[1] = 3
h_index[2] = 4
d_index = pycuda.gpuarray.to_gpu(h_index)

d_red = pycuda.gpuarray.subset_sum(d_index, d_x)
print(d_red)

d_red = pycuda.gpuarray.subset_max(d_index, d_x)
print(d_red)

d_red = pycuda.gpuarray.subset_min(d_index, d_x)
print(d_red)

d_red = pycuda.gpuarray.subset_dot(d_index, d_x, d_y)
print(d_red)

d_x = 1j * d_x
d_red = pycuda.gpuarray.dot(d_x, d_x)
print(d_red)

"""Array scrambling."""

h_x = np.zeros((5, 1), dtype = np.complex64)
h_x[0] = 11
h_x[1] = -4
h_x[2] = 77
h_x[3] = -14
h_x[4] = 0
d_x = pycuda.gpuarray.to_gpu(h_x)

h_index = np.zeros((3, ), dtype = np.int32)
h_index[0] = 3
h_index[1] = 4
h_index[2] = 0
d_index = pycuda.gpuarray.to_gpu(h_index)

d_x = pycuda.gpuarray.take(d_x, d_index)
print(d_x)

"""Casting and shape manipulations."""

h_x = np.zeros((5, 1), dtype = np.float32)
h_x[0] = 11.2
h_x[1] = -4.3
h_x[2] = 77.6
h_x[3] = -14.1
h_x[4] = 0.4
d_x = pycuda.gpuarray.to_gpu(h_x)

d_x = d_x.astype(np.int32)
print(d_x)

h_x = np.zeros((8, 1), dtype = np.float32)
h_x[0] = 11.2
h_x[1] = -4.3
h_x[2] = 77.6
h_x[3] = -14.1
h_x[4] = 0.4
h_x[5] = 0.6
h_x[6] = -20
h_x[7] = -12.4
d_x = pycuda.gpuarray.to_gpu(h_x)

d_x = d_x.reshape((2, 4))
print(d_x)

d_x = d_x.ravel()
print(d_x)

h_x = np.zeros((2, 4, 1), dtype = np.float32)
h_x[0, 0, 0] = 11.2
h_x[1, 0, 0] = -4.3
h_x[0, 1, 0] = 77.6
h_x[1, 1, 0] = -14.1
h_x[0, 2, 0] = 0.4
h_x[1, 2, 0] = 0.6
h_x[0, 3, 0] = -20
h_x[1, 3, 0] = -12.4
d_x = pycuda.gpuarray.to_gpu(h_x)
print(d_x[:, :, :])

d_x = d_x.squeeze()
print(d_x)

"""Other floating point operations."""

d_x = 1. + gpuarray.zeros((5, 1), np.float32)
d_y = 2. + gpuarray.zeros((5, 1), np.float32)

d_z = pycuda.cumath.fmod(d_x, d_y)
print(d_z)

d_z = pycuda.cumath.modf(d_x)
print(d_z)

"""Array information."""

print('Shape (dimensions, Matlab''s size)                : ', d_z.shape)
print('Type                                              : ', d_z.dtype)
print('Size (total number of elements)                   : ', d_z.size)
print('Size (total number of elements including padding) : ', d_z.mem_size)
print('Number of bytes                                   : ', d_z.nbytes)
print('Strides                                           : ', d_z.strides)
print('Array pointer                                     : ', d_z.ptr)
print('Row major?                                        : ', d_z.flags.c_contiguous)
print('Column major?                                     : ', d_z.flags.f_contiguous)
print('Any contiguity?                                   : ', d_z.flags.forc)
print(d_z.__cuda_array_interface__)

h_x = np.zeros((2, 4), dtype = np.float32)
h_x[0, 0] = 11.2
h_x[1, 0] = -4.3
h_x[0, 1] = 77.6
h_x[1, 1] = -14.1
h_x[0, 2] = 0.4
h_x[1, 2] = 0.6
h_x[0, 3] = -20
h_x[1, 3] = -12.4
d_x = pycuda.gpuarray.to_gpu(h_x)
print(d_x[1, 1 : 3])